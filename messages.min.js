"use strict";function Messages(encryption,db,serverURL,userData=null,sock=null,push=null,options={}){let serverIDK=null,user=null,opk=null,parentChannel="/messages";options&&options.parentChannel&&"string"==typeof options.parentChannel&&(parentChannel=db.path(options.parentChannel).channel());const REQUEST=async(method,payload)=>fetch(serverURL+"/"+method,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(payload)}).then(async response=>{var result=await response.json();if(399<response.statusCode)throw result;return result});const resetContact=async userID=>(await db.path(parentChannel).path("/contacts").path(userID).path("session").del(),await db.path(parentChannel).path("/contacts").path(userID).path("stale").del(),await sendMessage(userID,{reset:!0},!0),{reset:!0});const loadUser=async()=>{var exists;return userData&&(user=await encryption.loadUser(userData).catch(err=>null)),user||(exists=await db.path(parentChannel).path("/user").get().catch(err=>null))&&(user=await encryption.loadUser(exists.data)),user?await loadOPK():(user=await encryption.createUser(),await loadOPK(),await sendOPK()),await db.path(parentChannel).path("/user").put(user.save()),user},loadOPK=async()=>{var opkData=await db.path(parentChannel).path("/user/opk").get().catch(err=>null);return opkData?(opk=opkData.data,opkData.data):updateOPK()},updateOPK=async()=>(opk=await user.createOPK(),await db.path(parentChannel).path("/user/opk").put(opk),opk),getServerIDK=()=>serverIDK,getToken=async type=>{var tokenData=await db.path(parentChannel).path("/token").path(user.getID()).get().then(result=>result.data).catch(err=>null);return tokenData&&tokenData.decoded&&tokenData.decoded.exp>parseInt(Date.now()/1e3)?(serverIDK=tokenData.serverIDK,tokenData[type+"Token"]):hello().then(result=>result[type+"Token"]||null).catch(err=>{throw{error:"Could not obtain a token from the server."}})},sendOPK=async()=>{user||await loadUser(userData);var sealed=await getToken("user");if(!sealed)return Promise.reject({error:"Invalid or expired token."});sealed=await user.sealEnvelope(getServerIDK(),{opk:opk.card.opk,token:sealed}),await REQUEST("opk",sealed)},getMessages=async(limit=100)=>{user||await loadUser(userData);var sealed=await getToken("user");if(!sealed)return Promise.reject({error:"Invalid or expired token."});var subscriptionExists=await db.path(parentChannel).path("/push").get().catch(err=>null);let sub=null;subscriptionExists&&(sub=subscriptionExists.data.subscription.keys.auth);sealed=await user.sealEnvelope(getServerIDK(),{token:sealed,limit:parseInt(limit),sub:sub});let response=await REQUEST("messages",sealed);if(response){let msgs=[],ids=[];for(let i=0;i<response.data.length;i++){response.data[i].data.timestamp=new Date(parseInt(response.data[i].key.slice(3,16))).getTime();var msg=await(async env=>{let saved=null,opened=await user.openEnvelope(env);if(opened.plaintext&&opened.plaintext.init&&opened.plaintext.init.from&&opened.from!==opened.plaintext.init.from)return null;let userExists=await db.path(parentChannel).path("/contacts").path(opened.from).get().catch(err=>{return null});if(userExists&&userExists.data.blocked)return null;let exists=await db.path(parentChannel).path("/contacts").path(opened.from).path("session").get().catch(err=>{return null});if(exists){let session=await user.loadSession(exists.data);let read=await session.read(opened.plaintext).catch(err=>{return null});if(read){read.timestamp=env.timestamp;saved=await saveReadMessage(opened.from,read,env.protocol||false);if(!env.protocol)await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save())}else{if(opened.plaintext.init){if(!env.protocol)await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").put(session.save());session=await user.openSession(opened.plaintext.init,opk.secret);opk.used=true}else{let stale=await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").get().catch(err=>{return null});if(stale){if(!env.protocol)await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").put(session.save());session=await user.loadSession(stale.data)}}read=await session.read(opened.plaintext).catch(err=>{return null});if(read){read.timestamp=env.timestamp;saved=await saveReadMessage(opened.from,read,env.protocol||false);if(!env.protocol)await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save())}}return saved}else{let session=null;if(!opened.plaintext.init){let stale=await db.path(parentChannel).path("/contacts").path(opened.from).path("stale").get().catch(err=>{return null});if(!stale){await resetContact(opened.from).catch(err=>{return null});return null}session=await user.loadSession(stale.data)}else{session=await user.openSession(opened.plaintext.init,opk.secret);opk.used=true}let read=await session.read(opened.plaintext).catch(err=>{return null});if(read){read.timestamp=env.timestamp;saved=await saveReadMessage(opened.from,read,env.protocol||false);if(!env.protocol)await db.path(parentChannel).path("/contacts").path(opened.from).path("session").put(session.save())}else await resetContact(opened.from).catch(err=>{return null});return saved}})(response.data[i].data,opk);ids.push(response.data[i].key),msg&&!msg.protocol&&msgs.push(msg)}return ids.length&&await(async(sealed=[])=>{user||await loadUser(userData);var token=await getToken("user");if(!token)return Promise.reject({error:"Invalid or expired token."});sealed=await user.sealEnvelope(getServerIDK(),{token:token,ids:sealed});return await REQUEST("acknowledge",sealed)})(ids),0<response.data.length&&response.data.length<parseInt(limit)&&opk.used&&await updateOPK(),await sendOPK(),msgs.length&&gotMessagesHandler&&"function"==typeof gotMessagesHandler&&gotMessagesHandler(!0),msgs}return Promise.reject({code:400,message:"Failed to open envelope."})};let saveHandler=null;let gotMessagesHandler=null;const saveReadMessage=async(contact,save,protocol=!1)=>{var msg={to:user.getID(),from:contact,plaintext:save.plaintext,timestamp:save.timestamp,status:"received"};if(!protocol){save=await db.path(parentChannel).path("/contacts").path(contact).path("messages").path(save.timestamp).put(msg);return saveHandler&&"function"==typeof saveHandler&&saveHandler({path:save.path,msg:msg}),msg}if(protocol)return msg.plaintext&&msg.plaintext.reset&&(console.log("resetting session..."),await db.path(parentChannel).path("/contacts").path(contact).path("session").del(),await db.path(parentChannel).path("/contacts").path(contact).path("stale").del()),null};const sendMessage=async(to,msg,protocol=!1)=>{user||await loadUser(userData);var sent=await getToken("anon"),exists=await db.path(parentChannel).path("/contacts").path(to).path("session").get().catch(err=>null);let session=null;exists?session=await user.loadSession(exists.data):(send=await(async id=>{if(!user)await loadUser(userData);let token=await getToken("anon");return REQUEST("card",{token:token,msg:{id:id}}).catch(err=>{return null})})(to),session=await user.createSession(send),await db.path(parentChannel).path("/contacts").path(to).path("session").put(session.save()));var send=await session.send(msg);let sealed=await user.sealEnvelope(to,send);protocol&&(sealed.protocol=!0);sent=await REQUEST("send",{token:sent,msg:sealed}).catch(err=>null);return sent?(await db.path(parentChannel).path("/contacts").path(to).path("session").put(session.save()),await db.path(parentChannel).path("/contacts").path(to).path("messages").path(sent.timestamp).put({to:to,from:user.getID(),plaintext:msg,timestamp:sent.timestamp,status:"sent"}),Promise.resolve(sent)):Promise.reject({code:400,message:"Failed to send message!"})};const hello=async()=>{user||await loadUser(userData);var anonToken=await user.createOPK(),decoded=await REQUEST("hello",anonToken.card),opened=await user.openEnvelope(decoded);let userToken=opened.plaintext.userToken;anonToken=opened.plaintext.anonToken,decoded=JSON.parse(cryptic.toText(cryptic.decode(userToken.split(".")[1])));return serverIDK=opened.from,await db.path(parentChannel).path("/token").path(user.getID()).put({anonToken:anonToken,userToken:userToken,decoded:decoded,serverIDK:opened.from}),{anonToken:anonToken,userToken:userToken,decoded:decoded}};return{getMessages:getMessages,sendMessage:sendMessage,getID:()=>user.getID(),getToken:getToken,listContacts:async query=>db.path(parentChannel).path("/contacts").list(query),updateContact:async(userID,profile={},unread=!1)=>{var exists=await db.path(parentChannel).path("/contacts").path(userID).get().catch(err=>null);let updated=profile||{};return updated.timestamp=Date.now(),updated.unread=unread||!1,updated.userID=userID,exists&&exists.data&&(!updated.name&&exists.data.name&&(updated.name=exists.data.name),!updated.photo&&exists.data.photo&&(updated.photo=exists.data.photo)),db.path(parentChannel).path("/contacts").path(userID).put(updated)},resetContact:resetContact,deleteContact:async userID=>db.path(parentChannel).path("/contacts").path(userID).del(),listMessages:async(userID,query)=>db.path(parentChannel).path("/contacts").path(userID).path("messages").list(query),onSave:cb=>{saveHandler=cb},connect:async()=>{sock&&(sock.onError(console.log),sock.onState(async s=>{"connected"===s&&sock.send({id:user.getID(),token:await getToken("user")})}),sock.onMessage(async()=>{await getMessages()}),sock.getState()||sock.connect())},subscribe:async e=>{return push?push.getPermission().then(result=>"granted"===result).catch(err=>!1)?push.subscribe(serverURL+"/push/subscribe").then(async result=>db.path(parentChannel).path("/push").put({subscription:result.subscription}).then(saved=>({subscribed:!0}))):null:{supported:!1}},unsubscribe:async e=>push?push.unsubscribe(serverURL+"/push/unsubscribe").then(async result=>db.path(parentChannel).path("/push").del().then(deleted=>({unsubscribed:!0}))):{supported:!1},getContact:async userID=>db.path(parentChannel).path("/contacts").path(userID).get().then(result=>result.data).catch(err=>null),isSubscribed:async()=>db.path(parentChannel).path("/push").get().then(result=>!0).catch(err=>!1),onGotMessages:cb=>{gotMessagesHandler=cb}}}